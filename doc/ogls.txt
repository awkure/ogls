-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GLUT 3D engine showcase prototype
--   
--   GLUT 3D engine showcase prototype
@package ogls
@version 0.0.1.1


module OGLS.Engine.Sound
data SoundFlag
Application :: SoundFlag
Alias :: SoundFlag
AliasId :: SoundFlag
Async :: SoundFlag
Filename :: SoundFlag
Loop :: SoundFlag
Memory :: SoundFlag
NoDefault :: SoundFlag
NoStop :: SoundFlag
NoWait :: SoundFlag
Purge :: SoundFlag
Resource :: SoundFlag
Sync :: SoundFlag


module OGLS.Engine.Rendering.Text

-- | Font to use
font :: BitmapFont

-- | Print text to screen
screenPrint :: String -> IO ()


module OGLS.Engine.Rendering.Shaders.Light

-- | Aplly function to get light position
getLightPosition :: (GLdouble -> GLdouble -> GLdouble -> a) -> IO a

-- | Initialize lightning
prepareLight :: IO ()


module OGLS.Engine.Rendering.Primitives

-- | Generate points from the given count
points :: Int -> [(GLfloat, GLfloat, GLfloat)]

-- | Random monadic point position
randompos :: Int -> [(GLfloat, GLfloat, GLfloat)]

-- | Another variant of the previous function
randompos' :: Int -> [(GLfloat, GLfloat, GLfloat)]

-- | Generate random list of Ints
randomList :: Int -> IO [Int]

-- | There should be the same function inside Monoid package somewhere
atimes :: Monoid m => Int -> m -> m

-- | Face
face :: Normal3 GLfloat -> Vertex3 GLfloat -> Vertex3 GLfloat -> Vertex3 GLfloat -> Vertex3 GLfloat -> IO ()

-- | Cube
cube :: GLfloat -> IO ()


module OGLS.Engine.Rendering.Models


module OGLS.Engine.Rendering.Helpers

-- | TODO: TemplateHaskell
vector3f :: Float -> Float -> Float -> Vector3 GLfloat
vector3d :: Double -> Double -> Double -> Vector3 GLdouble
color3f :: Float -> Float -> Float -> Color3 GLfloat
color3d :: Double -> Double -> Double -> Color3 GLdouble
vertex3f' :: (GLfloat, GLfloat, GLfloat) -> IO ()
color3f' :: (GLfloat, GLfloat, GLfloat) -> IO ()
normal3f :: Float -> Float -> Float -> Normal3 GLfloat
normal3d :: Double -> Double -> Double -> Normal3 GLdouble
scalef :: Float -> Float -> Float -> IO ()
scaled :: Double -> Double -> Double -> IO ()
texCoord2f :: Float -> Float -> IO ()
texCoord2d :: Double -> Double -> IO ()
toVertex :: Num a => (a, a) -> IO ()
vertex2f :: Float -> Float -> Vertex2 GLfloat
vertex2d :: Double -> Double -> Vertex2 GLdouble
vertex3f :: Float -> Float -> Float -> Vertex3 GLfloat
vertex3d :: Double -> Double -> Double -> Vertex3 GLdouble

-- | Strict map `
strictMap :: (a -> b) -> [a] -> [b]

-- | Some implementation from Control.Parallel.Strategies I wanted to
--   change a bit for gaining full control
type Done = ()
type Strategy a = a -> Done

-- | Normal form data
class NFData a where rnf = rwhnf
rnf :: NFData a => Strategy a

-- | TODO: also TemplateHaskell

-- | Unit reduce
r0 :: Strategy a

-- | Reduce to Weak Head Normal Form
rwhnf :: Strategy a

-- | Another helper
using :: a -> Strategy a -> a

-- | Force evaluation of the given list force :: [a] -&gt; () force (x:xs)
--   = x <a>pseq</a> force xs force _ = ()
force :: Strategy a -> Strategy [a]

-- | Map the array in parallel
parMap :: Strategy b -> (a -> b) -> [a] -> [b]

-- | Another abstraction over combination of mapping and folding
mapReduce :: Strategy b -> (a -> b) -> Strategy c -> ([b] -> c) -> [a] -> c
instance OGLS.Engine.Rendering.Helpers.NFData (a -> b)
instance OGLS.Engine.Rendering.Helpers.NFData GHC.Types.Int


module OGLS.Engine.Math.Matrix


module OGLS.Engine.Math.Instances
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Bind.Class.Apply (Data.HashMap.Base.HashMap k)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Bind.Class.Bind (Data.HashMap.Base.HashMap k)
instance Data.Functor.Bind.Class.Apply Data.Complex.Complex
instance Data.Functor.Bind.Class.Bind Data.Complex.Complex
instance Control.Monad.Zip.MonadZip Data.Complex.Complex
instance Control.Monad.Fix.MonadFix Data.Complex.Complex
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Complex.Complex
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Complex.Complex


module OGLS.Engine.Math.Vectors
(^$+) :: forall (t :: * -> *) a. (Applicative t, Num a) => t a -> t a -> t a
infixl 6 ^$+
(^$-) :: forall (t :: * -> *) a. (Applicative t, Num a) => t a -> t a -> t a
infixl 6 ^$-
(^$*) :: forall (t :: * -> *) a. (Applicative t, Num a) => t a -> t a -> t a
infixl 7 ^$*

-- | Dot product
dot :: forall (t :: * -> *) a. (Applicative t, Foldable t, Num a) => t a -> t a -> a
step :: forall (t :: * -> *) a. (Applicative t, Num a, Ord a) => t a -> t a -> t a
instance GHC.Show.Show a => GHC.Show.Show (OGLS.Engine.Math.Vectors.Vec4 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (OGLS.Engine.Math.Vectors.Vec4 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (OGLS.Engine.Math.Vectors.Vec4 a)
instance GHC.Generics.Generic (OGLS.Engine.Math.Vectors.Vec3 a)
instance GHC.Show.Show a => GHC.Show.Show (OGLS.Engine.Math.Vectors.Vec3 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (OGLS.Engine.Math.Vectors.Vec3 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (OGLS.Engine.Math.Vectors.Vec3 a)
instance GHC.Base.Functor OGLS.Engine.Math.Vectors.Vec3
instance GHC.Base.Applicative OGLS.Engine.Math.Vectors.Vec3


module OGLS.Engine.Bindings
data State
State :: IORef GLdouble -> IORef GLfloat -> IORef GLfloat -> IORef (Vector3 GLfloat) -> IORef (Vector3 GLfloat) -> IORef (Vector3 GLfloat) -> IORef Bool -> IORef Bool -> IORef Int -> IORef [IO ()] -> IORef [Color4 GLclampf] -> IORef [Material] -> IORef Position -> IORef (Vector3 GLfloat) -> IORef Modifiers -> IORef (GLfloat, GLfloat) -> State

-- | Angle of inclination of particular model
[angle] :: State -> IORef GLdouble

-- | I use scaling model instead of moving camera aroind it
[scaleto] :: State -> IORef GLfloat

-- | Needed for calculating inertia
[delta] :: State -> IORef GLfloat

-- | Initial inertia of the given model
[inertia] :: State -> IORef (Vector3 GLfloat)

-- | Buffer for proper calculation
[inertiaOld] :: State -> IORef (Vector3 GLfloat)

-- | Difference of inclination while rotating model
[diff] :: State -> IORef (Vector3 GLfloat)

-- | Rotation toggle (on/off)
[shouldRotate] :: State -> IORef Bool

-- | Shading toggle (on/off)
[useShaders] :: State -> IORef Bool

-- | Don't remember where I used it
[point] :: State -> IORef Int

-- | Where models stored
[modelsCycle] :: State -> IORef [IO ()]

-- | Where backgrounds/skyboxes stored
[bgCycle] :: State -> IORef [Color4 GLclampf]

-- | Where materials stored
[matCycle] :: State -> IORef [Material]

-- | I'm so fucking tired
[lastPosition] :: State -> IORef Position

-- | Last increment while rotating model
[lastIncr] :: State -> IORef (Vector3 GLfloat)

-- | Needed for proper keyboardMouse callback work
[modifiers] :: State -> IORef Modifiers

-- | I wanted to move model around the scene but it's unimplemented rn
[pos] :: State -> IORef (GLfloat, GLfloat)
data ShaderFilePath
ShaderFilePath :: FilePath -> FilePath -> ShaderFilePath

-- | Path to .vert file
[vertexShaderFilePath] :: ShaderFilePath -> FilePath

-- | Path to .frag file
[fragmentShaderFilePath] :: ShaderFilePath -> FilePath
data Material
Material :: MaterialName -> {-# UNPACK #-} !(Color4 GLfloat) -> {-# UNPACK #-} !(Color4 GLfloat) -> {-# UNPACK #-} !(Color4 GLfloat) -> {-# UNPACK #-} !(Color4 GLfloat) -> {-# UNPACK #-} !GLfloat -> {-# UNPACK #-} !GLfloat -> Material

-- | Name of material being used
[mName] :: Material -> MaterialName

-- | Ambient map of the given material
[mAmbient] :: Material -> {-# UNPACK #-} !(Color4 GLfloat)

-- | Diffuse map of the given material
[mDiffuse] :: Material -> {-# UNPACK #-} !(Color4 GLfloat)

-- | Specular map of the given material
[mSpecular] :: Material -> {-# UNPACK #-} !(Color4 GLfloat)

-- | Emission ratio of the given material
[mEmission] :: Material -> {-# UNPACK #-} !(Color4 GLfloat)

-- | Shininess ration of the given material
[mShininess] :: Material -> {-# UNPACK #-} !GLfloat

-- | Refraction ratio of the given material
[mRefraction] :: Material -> {-# UNPACK #-} !GLfloat
shaderFilePath :: ShaderFilePath
timerFrequency :: Timeout
toVertex :: Num a => (a, a) -> IO ()

-- | Shows contents of the given IO monad
showIO :: Show a => IO (a) -> IO ()

-- | Don't remember where I used it
getTime :: IO Double

-- | Initialize state
prepareState :: IO State

-- | Toggles background color/skybox
nextBackground :: State -> IO ()
scaleIncrement :: Float
scaleFactor :: Float

-- | Resets given state
resetState :: State -> IO ()

-- | Calculates inertia using given state
runInertia :: State -> IO ()

-- | Toggles rotation for the given state
toggleRotation :: State -> IO ()

-- | Outputs help to stdout
help :: Text

-- | Pointless trying to draw text on the window
printHelp :: IO ()

-- | Force evaluation of the given list force :: [a] -&gt; () force (x:xs)
--   = x <a>pseq</a> force xs force _ = ()
force :: Strategy a -> Strategy [a]
instance GHC.Show.Show OGLS.Engine.Bindings.Material
instance GHC.Show.Show OGLS.Engine.Bindings.MaterialName
instance GHC.Show.Show OGLS.Engine.Bindings.ShaderFilePath


-- | Deprecated, use OGLS.Engine.Rendering.Text insead
module OGLS.Engine.Debug

-- | Initialize FPS
initFPS :: IO FPS

-- | Draws some debug information on the window
showFPS :: FPS -> Maybe String -> IO ()

-- | Handle different window sizes correctly by calculating the space
--   between subsequent lines; probably should be in <a>Display</a> module
showtext :: (GLfloat, GLfloat) -> [String] -> IO ()

-- | Won't work until I configure FGTL properly
drawHelp :: IO ()


module OGLS.Engine.Rendering.Shaders.Material

-- | Initialize material
prepareMaterial :: Material -> IO ()

-- | Cycle materials, used in <tt>keyboardMouse</tt> callback
nextMaterial :: State -> IO ()


module OGLS.Engine.Rendering.Shaders.GLSL

-- | Checks GLSL support
checkGLSLsupport :: IO ()

-- | Reads the given shader
compileShaders :: ShaderType -> FilePath -> IO Shader

-- | Install loaded shaders
installExampleShaders :: [Shader] -> IO ()

-- | Toggles shading via <tt>keyboardMouse</tt> callback
toggleShading :: State -> IO ()

-- | Alternative shading using built-in GLUT bindings
alternativeShading :: IO ()

-- | Initialize alternative shading
prepareShaders :: IO ()


module OGLS.Engine.Callbacks

-- | Handles window reshaping
reshape :: ReshapeCallback

-- | Handles mouse events/motion and how models should behave
motion :: State -> MotionCallback

-- | Handles keyboard and mouse events
keyboardMouse :: State -> KeyboardMouseCallback

-- | Registers timer callback
timer :: State -> TimerCallback


module OGLS.Engine.Rendering.Textures

-- | Just and alias of TextureSize2D
checkImageSize :: GLsizei -> GLsizei -> TextureSize2D

-- | Set up projective texture matrix. I use the Modelbiew matrix stack and
--   OpenGL matrix commands to make the matrix.
generateTextureMatrix :: IO ()

-- | Wrapper around readTexture that crashes on error
loadTexture2D :: FilePath -> IO TextureObject

-- | Setup a texture based on how
installTexture :: IO ()

-- | Variables that I intended to use alot in future
lookat :: Vertex3 GLdouble
up :: Vector3 GLdouble


module OGLS.Engine.Rendering.Display

-- | Useless rn
radius :: GLdouble

-- | Perhaps I had to move it to Callbacks module
primaryDisplay :: State -> DisplayCallback

-- | Make 2D plane which represents floor of the scene (unused)
prepareFloor :: Bool -> IO ()


module OGLS.Engine.Rendering.Skybox
data Skybox
Skybox :: Maybe TextureObject -> Maybe TextureObject -> Maybe TextureObject -> Maybe TextureObject -> Maybe TextureObject -> Maybe TextureObject -> Skybox

-- | Front side
[front] :: Skybox -> Maybe TextureObject

-- | Right side
[right] :: Skybox -> Maybe TextureObject

-- | Back side
[back] :: Skybox -> Maybe TextureObject

-- | Left side
[left] :: Skybox -> Maybe TextureObject

-- | Top side
[top] :: Skybox -> Maybe TextureObject

-- | Bottom side
[bottom] :: Skybox -> Maybe TextureObject

-- | Load textures needed for skybox initialization from `data/img/Skybox`
--   directory
loadSkybox :: IO Skybox

-- | Make the given skybox from loaded texture objects
drawSkybox :: Skybox -> IO ()


module OGLS.Core
